## CS 지식 정리

### DB

**데이터베이스 제약 조건**

```
- 테이블에 잘못된 데이터의 입력을 막기 위해 일정한 규칙을 지정하는 것
```

- PK (Primary Key)
  - **중복되지 않아야 하고 NULL값을 가질 수 없다.**
  - 테이블 생성시 고유한 한개의 Key
  - PK를 기준으로 하는 클러스터드 인덱스가 자동 생성된다.
- FK (Foreign Key)
  - 참조되는 컬럼은 PK이거나 Unique Key여야 한다.
  - null값 허용

**트랜잭션**

- 데이터베이스의 상태를 변화시키기 위해 수행하는 하나의 논리적인 작업 단위 
- 데이터베이스를 트랜잭션 단위로 동작시킴으로써 작업의 완전성, 무결성을 지킬 수 있다. 

**트랜잭션의 특징**

1. 원자성 : 트랙잭션은 DB에 모두 반영되거나(commit) 전혀 반영되지 않아야한다.(rollback)
2. 일관성 : 트랜잭션 작업 전과 후에 항상 같은 상태를 유지해야한다. 데이터의 고유한 특징이 일관되게 보장되어야한다.
3. 고립성 : 각각의 트랜잭션이 서로 영향받거나 끼어들 수 없어야 한다. 
4. 지속성 : 성공(완료)된 트랜잭션의 결과는 영구적으로 반영되어야한다. 

**트랜잭션 고립 (isolation) 레벨** (격리 수준)

- READ_UNCOMMITED
  - 가장 낮은 격리수준
  - 하나의 트랜잭션이 커밋되기 전에 그 변화가 다른 트랜잭션에 노출된다.
- READ_COMMITED
  - 트랜잭션이 커밋하지 않은 정보는 읽을 수 없다. 
  - 부정합 문제 발생 가능
    - A트랜잭션에서 a의 나이를 조회 - 20 
    - B트랜잭션에서 a의 나이를 21로 변경
    - A트랜잭션에서 a를 조회 - 21
    - 하나의 트랜잭션 내에서 select 수행의 결과가 달라질 수 있다.
- REPEATABLE_READ
  - 하나의 트랜잭션이 읽은 row를 다른 트랜잭션이 수정할 수 없다.
  - 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회 가능 (undo공간에서 읽어옴)
  - MYSQL 기본 설정
    - 팬텀 리드 문제 알아보기 - InnoDB에서는 팬텀리드 막아주고있다.
- SERIALIZABLE 
  - 가장 강력한 격리 수준으로 여러 트랜잭션이 동시에 같은 테이블에 접근할 수 없다.

---

**프로세스와 쓰레드의 차이점**

- 프로세스는 메모리에 적재되어 수행중인 프로그램
- 쓰레드는 CPU의 실제 논리적 작업 단위

프로세스는 한번 생성됐을때 독립적인 프로세스 주소공간을 가지고 인터럽트가 발생했을 때 컨텍스트 스위칭 되는 오버헤드가 크다. 프로세스간 통신은 IPC(공유 메모리, 메세지큐, 파이프라인 등)을 이용해야한다.  

쓰레드는 한 프로세스 안에서 공통되는 데이터나 코드영역을 공유하고 스택만 개별적으로 가진다. 프로세스안에서 여러 쓰레드가 수행될수 있다. 공유 자원에 대한 처리가 필요하다.

**동시성, 병렬처리**

- 동시성 : 실제로는 동시에 수행되고 있는건 아니지만 사용자가 볼 때 동시에 수행되는것 처럼 빠르게 시간을 나눠서 처리
- 병렬 처리 : 실제 CPU 개수만큼 병렬 처리(동시에 수행)

**DMA**

- Direct Memoy Access, I/O를 CPU 간섭없이 직접 하고, 버퍼에 I/O작업물을 담아놓고 CPU에게 인터럽트로 알림  
- CPU는 오래걸리는 I/O 작업 동안 다른 일을 할 수 있음  

**GC 동작** 

- 힙 메모리영역을 자동으로 해제해줌
- Minor GC (young 영역 안에서의 GC Eden - Survivor)
- Major GC (old영역)
  - GC가 일어날 때는 모든 실행중인 스레드가 정지된다 (Stop the world)
  - Major GC에서는 이 시간이 오래걸림
  - Mark - Sweep - Compaction  
    - Mark : reachable한 객체 탐색
    - Sweep : unreachable한 객체 해제
    - Compaction : 외부단편화를 예방하기 위해 압축

**Tree와 그래프**

- 그래프
  - 노드, 엣지로 이루어진 자료구조
- 트리
  - 방향성이 존재하고 싸이클이 없고 하나의 노드에서 다른 노드로 가는 경로가 하나만 존재한다. 

**대표적인 그래프 탐색 방법**

모두 O(N+E)의 시간복잡도

- DFS (깊이우선)
  - 하나의 노드에서 갈 수 있는 노드를 끝까지 탐색한 후에 돌아옴
  - 스택, 재귀함수로 구현
- BFS (너비우선)
  - 하나의 노드에서 갈 수 있는 같은 레벨에 존재하는 모든 노드를 먼저 탐색 (인접한 노드를 먼저 탐색)
  - 최소비용 계산에 적합, 큐로 구현 

**TCP 연결,종료 과정**

신뢰성있는 데이터 전송을 보장한다.

- 3 way handshake
  - 클라이언트는 서버에 접속을 요청하는 SYN 패킷을 보낸다. (랜덤 시퀀스 번호 할당됨)
  - 서버는 클라이언트에게 응답패킷인 ACK과 접속 요청 SYN 패킷을 함께 보낸다. (ACK은 시퀀스번호+1)
  - 클라이언트는 서버에게 응답패킷 ACK을 보낸다.
  - 연결 성립된다.
- 4 way handshake
  - 클라이언트는 서버에게 연결을 종료하겠다는 FIN패킷을 보낸다. (클라이언트는 FIN_WAIT상태가 됨)
  - 서버는 클라이언트의 FIN에 대한 응답 패킷 ACK을 보낸다. (서버는 CLOSE_WAIT상태)
  - 서버가 처리할 모든 통신이 끝나면 연결을 종료한다는 FIN패킷을 보낸다. (서버 LAST_ACK)
  - 클라이언트는 ACK패킷을 보낸다. (클라이언트 FIN_WAIT -> TIME_WAIT)
    - 서버가 클라이언트에게 FIN패킷을 전송하기 전에 보낸 패킷이 지연되거나 유실되었을 경우를 대비해 클라이언트는 서버로부터 FIN을 받더라도 일정 시간동안 연결을 종료하지않고 기다린다. (TIME_WAIT)
  - 클라이언트의 ACK을 받은 서버는 소켓 연결을 종료한다. (CLOSE)

**@Transactional이란**

- 스프링에서 어노테이션을 이용해서 선언적 트랜잭션방식으로 이용
- connection, close 해줌 
- 트랜잭션 추상화를 통해 드라이버마다 종속되지 않고 일관되게 트랜잭션 처리 가능 (PSA)
  - commit, rollback 공통적으로 사용 
- AOP
  - @Transactional 어노테이션이 있으면 트랜잭션 생성,종료 로직을 별도로 빼내고 핵심 비즈니스 로직만 작성할 수 있게 해줌



**AOP란** (잘 모르겠어서 더 정리 필요 ㅠㅠ )

관점지향프로그래밍, 핵심 로직 이외의 트랜잭션, 로깅과 같은 매번 메서드마다 공통으로 사용되는 부가 기능들을 횡단으로 분리해서 관리

- Advice : 타겟 오브젝트에 적용하는 부가기능의 코드
  - 어드바이스의 동작 시점 Before, After, Around 드 ㅇ
- JoinPoint : 클라이언트가 호출하는 비즈니스 메소드, 포인트컷의 후보
- PointCut : 특정 조건에 의해 필터리 된 조인포인트
- Weaving : 포인트컷으로 지정한 핵심 관심 메소드가 호출될 때 어드바이스에 해당하는 메소드가 삽입되는 과정
- Aspect : 포인트컷과 어드바이스의 결합



**프록시패턴**

객체를 직접 참조하는 것이 아닌, 해당 객체에 대응하는 프록시 객체를 통해 대상 객체에 접근하는 방식  

해당 객체가 메모리에 존재하지 않아도 기본적인 정보를 참조하거나 설정할 수 있고, 실제 객체의 기능이 필요한 시점까지 객체의 생성을 미룰 수 있다. 인터페이스를 이용해 실제 객체 대리자역할을 수행 

**빌더패턴**

- 필요한 데이터만 설정할 수 있다
- 객체 생성시 가독성을 높일 수 있다
- setter를 사용하지 않아 변경 가능성을 최소화할 수 있다.
- 파라미터순서,오버로딩 문제 해결, 체이닝 방식으로 생성 

**jpa**

jpa는 영속성컨텍스트 메모리공간을 따로 두어서 db접근과정 간소화

1. 지연로딩을 통해 연관관계 객체들을 실제로 필요할때만 db 에서조회함
2. 1차캐시
   DB에서 가져오기 전에 1차캐시에서 먼저 조회하여 빠르게 가져올 수 있다.
3. 더티체킹 
   1차캐시에 들어있는 엔티티의 값이 변경되면 flush가 일어날 때 값을 비교해서 save, persister를 명시적으로 호추하지 않아도 업데이트된 정보를 DB에 반영해준다 .

**scale out scale up**

- 스케일업 
  - 기존 서버를 높은 사양으로 업그레이드
  - 실제 하드웨어, CPU, 메모리 업그레이드 
- 스케일아웃
  - 장비를 추가해서 확장하는 방식
  - 비슷한 사양의 서버를 여러대두어 기존 서버의 부하를 분담
  - 확장에 유연하다
  - 분산처리를 위해 로드밸런서를 사용한다. 
