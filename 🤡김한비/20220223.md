자바 8에서 생긴 큰 변화.. 함수형프로그래밍(함수형인터페이스,람다), 스트림, 병렬처리 등을 다룰 예정  
사실 그냥 책이랑 강의자료 보기 좋게 나열한것과 다를바 없음  
*참고자료: 모던 자바 인 액션, 더 자바, Java 8 강의(인프런),  effective java 3(거의 안봄 ㅎ)*


## 자바에서 함수형 프로그래밍  
기존 자바에서 함수 = 수학적인 함수, 어떤 결과를 내는데 활용을 할 수 있지만 그 자체가 값이 될 수 없음  
자바8 에서의 함수 = 값처럼 취급 가능,  더이상 정적인 메서드가 아님, 값 변경 가능 = 일급 값/시민/객체(first class citizen)  
함수에서 함수 밖에 있는 값을 변경할 수 없고 상태가 없는 순수함수, 함수가 함수를 매개변수로 받거나 리턴하기 가능  

이미 자바스크립트, 그루비 같은 언어에서 함수를 일급값으로 사용하고 있음  
프로그래밍이 매우 수월해짐, 이건 뒤에서 확인가능  
<br>

## 1. 함수형 인터페이스와 람다 표현식
### 인터페이스
코드의 규격 같은것(설계도?ㅋㅋ)  
상수 public static final / 추상메소드 abstract method로 이루어짐
abstract 키워드 생략 가능  
static, default method 선언 가능

### 함수형 인터페이스
**추상메소드가 1개**(SAM, single abstract method)  
@FuncationInterface 애노테이션 달림  

그래서 이걸 어따 쓰냐고  
<br>
추상메소드가 한개면, 인터페이스를 실제로 구현할때 기존과 달리 줄여서 구현 가능  
기존에 RunSomething이라는 인터페이스가 있을때 이를 구현하려면
```
RunSomething rs = new RunSomething(){
  @Override
  public void do(){
    ~~~~
  }
};

rs.do(); 
```
이렇게 구질구질하게 적었어야 됐는데  
이젠 한줄로 처리 가능

```
RunSomething rs = ()->~~~;
rs.do(); 
```

### 람다 표현식
함수형 인터페이스의 인스턴스를 만드는 빙법으로 쓰임
람다 자체가 파라미터, 리턴타입, 변수가 될 수 있음
<br>

## 2. 동작파라미터화(behavior parameterization)
정의: 아직 어떻게 실행할 것인지 결정되지 않은 코드블록  
코드블록이 프로그램에서 호출되기 때문에 동작 실행이 나중으로 미뤄짐(메서드 동작이 파라미터화 된다)  


예)  
리스트의 모든 요소에 대해 "어떤 동작"을 수행할 수 있음  
에러가 발생하면 "정해진 어떤 동작"을 수행할 수 있음  
즉. 어떤 동작이 상황에 따라 결정되는..그런거라고 할 수 있음  

장점: 자주 바뀌는 요구사항에 유연하게 대처 가능

와닿지 않으므로 예제로 고고

<br>

## 사과 분류 예제
고객이 사과를 색깔별로 분류하는 프로그램을 만들어달라고 했음
<br>

### 그냥 짜보기(아메바)
- 사과 배열을 돌면서 특정 색과 같다면 List에 넣는 함수 작성

```
  public static List<Apple> filterGreenApples(List<Apple> inventory) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
      if (apple.getColor() == Color.GREEN) {
        result.add(apple);
      }
    }
    return result;
  }
```
만약, 고객이 빨간사과도 필터링해서 리턴해달라고 하면? -> 위 함수를 복붙해서 빨간거를 거르는걸 새로 만들 수 있음 
근데 이건 매우 비효율적인 방법임
<br>

### 색을 파라미터화(원숭이)
- 비슷한 코드가 반복된다면, 그 코드를 추상화 해야함
```
 public static List<Apple> filterApplesByColor(List<Apple> inventory, Color color) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
      if (apple.getColor() == color) {
        result.add(apple);
      }
    }
    return result;
  }
```
이러면 걸러낼 색이 달라져도 저 함수 하나만 호출하면 됨  
근데 고객이 "색 외에도 무게로 구분하는것도 추가해주세요"라고 말한다면?  
색을 파라미터화 한 것과 같이 무게도 파라미터화 할 수 있음  

```
 public static List<Apple> filterApplesByWeight(List<Apple> inventory, int weight) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
      if (apple.getWeight() > weight) {
        result.add(apple);
      }
    }
    return result;
  }
```

난 여기서 만족하는 편인데 이것도 좋은코드가 아니라함  
왜냐면 color, weight을 구분하는 함수 모두 대부분의 내용이 중복됨  
-> DRY(don't repeat yourself) 원칙을 어기는것  
<br>

플래그를 추가해서 짜는 방법도 있지만
```
 public static List<Apple> filterApplesByWeight(List<Apple> inventory, Color color, int weight, boolean flag) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
      if ((flag && apple.getColor().equals(color)) ||
              (!flag &&apple.getWeight() > weight)) {
        result.add(apple);
      }
    }
    return result;
  }
```
<br>
실전에서 이 방법은 매우매우 좋지 않다고 함  
다음과 같이 메서드를 사용하게 되는데  
```
List<Apple> greenApples = filterApples(inventory, GREEN, 0, true); 
```
true가 뭔지 파악하기가 힘듦, 그리고요구사항 추가될수록 flag가 덕지덕지 늘어날거임 ㅠ
<br>

### 동작파라미터화 사용(사람)
조건에 그만 끌려다니자~~  

