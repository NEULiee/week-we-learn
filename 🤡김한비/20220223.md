Java 8에서 생긴 큰 변화를 다룰 예정  
사실 그냥 책이랑 강의자료 보기 좋게 나열한것과 다를바 없음  
*참고자료: 모던 자바 인 액션, 더 자바, Java 8 강의(인프런),  effective java 3(거의 안봄 ㅎ)*

<br>

>Q. 왜 Java 8을 공부하라고 할까?  
>A. Java 역사상 가장 큰 변화가 일어난 버전, 따라서 이걸 알아야 자바를 쓸 줄 안다고 할 수 있음
> 
>Q. 어떤 변화가 일어났나?  
>A. 간결한 코드 작성 / 멀티코어 프로세서의 쉬운 활용   
> &nbsp; &nbsp;&nbsp; 원래 스레드로 병렬 환경을 구성했는데, 8부터 기존보다 쉽게 멀티코어 병렬성을 이용할 수 있게 됨  
> &nbsp; &nbsp;&nbsp; 함수형 프로그래밍을 지원하게 되면서 코드가 간결해짐(Lambda, Stream...)  
> &nbsp; &nbsp;&nbsp; 그 외에도 이전 버전에서 불편했던 날짜표시가 개선되고 Optional을 이용해 null 체크를 효율적으로 할 수 있게 됨

<br>

## Java 8 설계의 밑바탕을 이루는 세가지 개념(차차 설명 후 링크달거임)
### 1. 스트림 처리

### 2. 동작파라미터화로 메서드에 코드 전달하기

### 3. 병렬성과 공유 가변 데이터


<br>

## 함수와 함수형프로그래밍
* 기존 자바에서 함수:  수학적인 함수, 어떤 결과를 내는데 활용을 할 수 있지만 그 자체가 값이 될 수 없음  
* 자바8 에서의 함수: 값처럼 취급 가능,  더이상 정적인 메서드가 아님, 일급 값/시민/객체(first class citizen)  

### 선언형 프로그래밍과 명령형 프로그래밍
명령형: "어떻게" 프로그래밍을 할건지에 집중 / ex)  A를 하고 B를 하고.. 처럼 단계별 작업 수행에 집중 / 고전적인 객체지향프로그래밍 방법  
선언형: "무엇을" 프로그래밍 하는지에 집중, 문제 자체를 코드로 드러냄/ ex) 코드 자체로 문제 해결방식을 한번에 파악 가능(앞으로 소개할 방식) / 함수형 프로그래밍의 기반

<br>

### 그래서 함수형프로그래밍이 뭔데?
>함수를 이용하는 프로그래밍 

그럼 함수가 뭔데?
> 수학적인 함수와 같지만 "부작용"이 없는것.

부작용 없는게 뭔데?
> 자신을 포함하는 클래스의 상태, 또는 객체의 상태를 상태를 바꾸지 않고 return 을 통해서만 자신의 결과를 반환하는 것  
> 인수가 같으면 반복 호출시 항상 같은 결과만 반환하는걸 보장해야함  
>* 지역 변수만을 변경  
>* 참조하는 객체는 모두 불변이어야 함(객체의 field는 final,참조필드는 불변객체 직접 참조해야함)  
>* 어떠한 예외도 일으켜선 안됨(예외 처리 과정에서 입력->출력 하는 모델이 깨질 수 있기 때문)  
>* 비함수형 동작을 감출 수 있는 상황에서만 부작용을 포함하는 라이브러리 사용 가능
> 그림추가..

부작용이 일어난 기준은?
> 함수 그리고 if-else 같은 수학적 표현만 사용하는 방식은 당연히 순수 함수형 프로그래밍임
> 시스템의 다른 부분에 영향을 미치지 않는다면, 내부적으로 함수형이 아닌 기능이라도 함수형 프로그래밍이라고 할 수 있음  
> 왜 위와 같이 얼레벌레한 방법을 쓰냐면, 자바에서는 완벽한 순수 함수형 프로그래밍을 구현하기 어렵기 때문이다.. 그래서 겉으로 보이기에 함수형 프로그래밍이 되는것처럼 할것임  










<br>


## 1. 함수형 인터페이스와 람다 표현식
### 인터페이스
코드의 규격 같은것(설계도?ㅋㅋ)  
상수 public static final / 추상메소드 abstract method로 이루어짐
abstract 키워드 생략 가능  
static, default method 선언 가능

### 함수형 인터페이스
**추상메소드가 1개**(SAM, single abstract method)  
@FuncationInterface 애노테이션 달림

그래서 이걸 어따 쓰냐고  
<br>
추상메소드가 한개면, 인터페이스를 실제로 구현할때 기존과 달리 줄여서 구현 가능  
기존에 RunSomething이라는 인터페이스가 있을때 이를 구현하려면
```
RunSomething rs = new RunSomething(){
  @Override
  public void do(){
    ~~~~
  }
};

rs.do(); 
```
이렇게 구질구질하게 적었어야 됐는데  
이젠 한줄로 처리 가능

```
RunSomething rs = ()->~~~;
rs.do(); 
```

### 람다 표현식
함수형 인터페이스의 인스턴스를 만드는 빙법으로 쓰임
람다 자체가 파라미터, 리턴타입, 변수가 될 수 있음
<br>

## 2. 동작파라미터화(behavior parameterization)
정의: 아직 어떻게 실행할 것인지 결정되지 않은 코드블록  
코드블록이 프로그램에서 호출되기 때문에 동작 실행이 나중으로 미뤄짐(메서드 동작이 파라미터화 된다)


예)  
리스트의 모든 요소에 대해 "어떤 동작"을 수행할 수 있음  
에러가 발생하면 "정해진 어떤 동작"을 수행할 수 있음  
즉. 어떤 동작이 상황에 따라 결정되는..그런거라고 할 수 있음

장점: 자주 바뀌는 요구사항에 유연하게 대처 가능

와닿지 않으므로 예제로 고고

<br>

## 사과 분류 예제
고객이 사과를 색깔별로 분류하는 프로그램을 만들어달라고 했음
<br>

### 그냥 짜보기(아메바)
- 사과 배열을 돌면서 특정 색과 같다면 List에 넣는 함수 작성

```
  public static List<Apple> filterGreenApples(List<Apple> inventory) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
      if (apple.getColor() == Color.GREEN) {
        result.add(apple);
      }
    }
    return result;
  }
```
만약, 고객이 빨간사과도 필터링해서 리턴해달라고 하면? -> 위 함수를 복붙해서 빨간거를 거르는걸 새로 만들 수 있음
근데 이건 매우 비효율적인 방법임
<br>

### 색을 파라미터화(원숭이)
- 비슷한 코드가 반복된다면, 그 코드를 추상화 해야함
```
 public static List<Apple> filterApplesByColor(List<Apple> inventory, Color color) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
      if (apple.getColor() == color) {
        result.add(apple);
      }
    }
    return result;
  }
```
이러면 걸러낼 색이 달라져도 저 함수 하나만 호출하면 됨  
근데 고객이 "색 외에도 무게로 구분하는것도 추가해주세요"라고 말한다면?  
색을 파라미터화 한 것과 같이 무게도 파라미터화 할 수 있음

```
 public static List<Apple> filterApplesByWeight(List<Apple> inventory, int weight) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
      if (apple.getWeight() > weight) {
        result.add(apple);
      }
    }
    return result;
  }
```

난 여기서 만족하는 편인데 이것도 좋은코드가 아니라함  
왜냐면 color, weight을 구분하는 함수 모두 대부분의 내용이 중복됨  
-> DRY(don't repeat yourself) 원칙을 어기는것  
<br>

플래그를 추가해서 짜는 방법도 있지만
```
 public static List<Apple> filterApplesByWeight(List<Apple> inventory, Color color, int weight, boolean flag) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
      if ((flag && apple.getColor().equals(color)) ||
              (!flag &&apple.getWeight() > weight)) {
        result.add(apple);
      }
    }
    return result;
  }
```
<br>
실전에서 이 방법은 매우매우 좋지 않다고 함   
다음과 같이 메서드를 사용하게 되는데  

```
List<Apple> greenApples = filterApples(inventory, GREEN, 0, true); 
```

true가 뭔지 파악하기가 힘듦, 그리고요구사항 추가될수록 flag가 덕지덕지 늘어날거임 ㅠ
<br>


### 동작파라미터화 사용(사람)
조건이 들어올때마다 새로운걸 추가하지 말자  
결국 사과의 어떤 속성이 TRUE/FALSE인지 확인하는게 중요함 -> 사과 검사 조건을 캡슐화  
위에서 배운 함수형 인터페이스와 람다를 이용하자!  
※ Predicate: TRUE/FALSE를 반환하는 함수형 인터페이스

사진 있는데 회사에서 업로드가 안됨

선택조건을 결정하는 인터페이스
```
interface ApplePredicate {
    boolean test(Apple a);
}
```

사용자의 요구사항에 따라 다양한 버전의 조건 정의 가능
```
static class AppleWeightPredicate implements ApplePredicate {

    @Override
    public boolean test(Apple apple) {
      return apple.getWeight() > 150;
    }

  }

  static class AppleColorPredicate implements ApplePredicate {

    @Override
    public boolean test(Apple apple) {
      return apple.getColor() == Color.GREEN;
    }

  }

  static class AppleRedAndHeavyPredicate implements ApplePredicate {

    @Override
    public boolean test(Apple apple) {
      return apple.getColor() == Color.RED && apple.getWeight() > 150;
    }

  }
```

Predicate를 이용해서 필터링 메소드를 바꾸면 다음과 같음
```
public static List<Apple> filter(List<Apple> inventory, ApplePredicate p) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
      if (p.test(apple)) {
        result.add(apple);
      }
    }
    return result;
  }
  
// [Apple{color=GREEN, weight=80}, Apple{color=GREEN, weight=155}]
List<Apple> greenApples2 = filter(inventory, new AppleColorPredicate());

// [Apple{color=GREEN, weight=155}]
List<Apple> heavyApples = filter(inventory, new AppleWeightPredicate());
    
// []
List<Apple> redAndHeavyApples = filter(inventory, new AppleRedAndHeavyPredicate());
```

이제 더이상 비슷한 코드를 복붙하고 수정하는 멍청한짓을 하지 않아도 됨  
ApplePredicate 인터페이스를 구현하는 클래스만 만들면 됨

근데 이 코드도 좀 귀찮긴 함  
조건마다 구현하는 클래스를 저렇게 정성스럽게 정의해야되는데 이걸 개발자들이 참을리가 없음  
그래서 익명클래스, 람다를 사용하게 됨!
여기서부턴 다음시간에 계속..
