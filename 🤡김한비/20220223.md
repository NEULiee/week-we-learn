자바 8에서 생긴 큰 변화.. 함수형프로그래밍(함수형인터페이스,람다), 스트림, 병렬처리 등을 다룰 예정  
사실 그냥 책이랑 강의자료 보기 좋게 나열한것과 다를바 없음  
*참고자료: 모던 자바 인 액션, 더 자바, Java 8 강의(인프런),  effective java 3(거의 안봄 ㅎ)*


## 자바에서 함수형 프로그래밍  
기존 자바에서 함수 = 수학적인 함수, 어떤 결과를 내는데 활용을 할 수 있지만 그 자체가 값이 될 수 없음  
자바8 에서의 함수 = 값처럼 취급 가능,  더이상 정적인 메서드가 아님, 값 변경 가능 = 일급 값/시민/객체(first class citizen)  
함수에서 함수 밖에 있는 값을 변경할 수 없고 상태가 없는 순수함수, 함수가 함수를 매개변수로 받거나 리턴하기 가능  

이미 자바스크립트, 그루비 같은 언어에서 함수를 일급값으로 사용하고 있음  
프로그래밍이 매우 수월해짐, 이건 뒤에서 확인가능  
<br>

## 1. 함수형 인터페이스와 람다 표현식
### 인터페이스
코드의 규격 같은것(설계도?ㅋㅋ)  
상수 public static final / 추상메소드 abstract method로 이루어짐
abstract 키워드 생략 가능  
static, default method 선언 가능

### 함수형 인터페이스
**추상메소드가 1개**(SAM, single abstract method)  
@FuncationInterface 애노테이션 달림  

그래서 이걸 어따 쓰냐고  
<br>
추상메소드가 한개면, 인터페이스를 실제로 구현할때 기존과 달리 줄여서 구현 가능  
기존에 RunSomething이라는 인터페이스가 있을때 이를 구현하려면
```
RunSomething rs = new RunSomething(){
  @Override
  public void do(){
    ~~~~
  }
};

rs.do(); 
```
이렇게 구질구질하게 적었어야 됐는데  
이젠 한줄로 처리 가능

```
RunSomething rs = ()->~~~;
rs.do(); 
```

### 람다 표현식
함수형 인터페이스의 인스턴스를 만드는 빙법으로 쓰임
람다 자체가 파라미터, 리턴타입, 변수가 될 수 있음
<br>

## 2. 동작파라미터화(behavior parameterization)
정의: 아직 어떻게 실행할 것인지 결정되지 않은 코드블록  
코드블록이 프로그램에서 호출되기 때문에 동작 실행이 나중으로 미뤄짐(메서드 동작이 파라미터화 된다)  


예)  
리스트의 모든 요소에 대해 "어떤 동작"을 수행할 수 있음  
에러가 발생하면 "정해진 어떤 동작"을 수행할 수 있음  
즉. 어떤 동작이 상황에 따라 결정되는..그런거라고 할 수 있음  

장점: 자주 바뀌는 요구사항에 유연하게 대처 가능

와닿지 않으므로 예제로 고고

<br>

## 사과 분류 예제
고객이 사과를 색깔별로 분류하는 프로그램을 만들어달라고 했음
<br>

### 그냥 짜보기(아메바)
- 사과 배열을 돌면서 특정 색과 같다면 List에 넣는 함수 작성

```
  public static List<Apple> filterGreenApples(List<Apple> inventory) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
      if (apple.getColor() == Color.GREEN) {
        result.add(apple);
      }
    }
    return result;
  }
```
만약, 고객이 빨간사과도 필터링해서 리턴해달라고 하면? -> 위 함수를 복붙해서 빨간거를 거르는걸 새로 만들 수 있음 
근데 이건 매우 비효율적인 방법임
<br>

### 색을 파라미터화(원숭이)
- 비슷한 코드가 반복된다면, 그 코드를 추상화 해야함
```
 public static List<Apple> filterApplesByColor(List<Apple> inventory, Color color) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
      if (apple.getColor() == color) {
        result.add(apple);
      }
    }
    return result;
  }
```
이러면 걸러낼 색이 달라져도 저 함수 하나만 호출하면 됨  
근데 고객이 "색 외에도 무게로 구분하는것도 추가해주세요"라고 말한다면?  
색을 파라미터화 한 것과 같이 무게도 파라미터화 할 수 있음  

```
 public static List<Apple> filterApplesByWeight(List<Apple> inventory, int weight) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
      if (apple.getWeight() > weight) {
        result.add(apple);
      }
    }
    return result;
  }
```

난 여기서 만족하는 편인데 이것도 좋은코드가 아니라함  
왜냐면 color, weight을 구분하는 함수 모두 대부분의 내용이 중복됨  
-> DRY(don't repeat yourself) 원칙을 어기는것  
<br>

플래그를 추가해서 짜는 방법도 있지만
```
 public static List<Apple> filterApplesByWeight(List<Apple> inventory, Color color, int weight, boolean flag) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
      if ((flag && apple.getColor().equals(color)) ||
              (!flag &&apple.getWeight() > weight)) {
        result.add(apple);
      }
    }
    return result;
  }
```
<br>
실전에서 이 방법은 매우매우 좋지 않다고 함   
다음과 같이 메서드를 사용하게 되는데  

```
List<Apple> greenApples = filterApples(inventory, GREEN, 0, true); 
```

true가 뭔지 파악하기가 힘듦, 그리고요구사항 추가될수록 flag가 덕지덕지 늘어날거임 ㅠ
<br>


### 동작파라미터화 사용(사람)
조건이 들어올때마다 새로운걸 추가하지 말자  
결국 사과의 어떤 속성이 TRUE/FALSE인지 확인하는게 중요함 -> 사과 검사 조건을 캡슐화  
위에서 배운 함수형 인터페이스와 람다를 이용하자!  
※ Predicate: TRUE/FALSE를 반환하는 함수형 인터페이스

사진 있는데 회사에서 업로드가 안됨

선택조건을 결정하는 인터페이스
```
interface ApplePredicate {
    boolean test(Apple a);
}
```

사용자의 요구사항에 따라 다양한 버전의 조건 정의 가능
```
static class AppleWeightPredicate implements ApplePredicate {

    @Override
    public boolean test(Apple apple) {
      return apple.getWeight() > 150;
    }

  }

  static class AppleColorPredicate implements ApplePredicate {

    @Override
    public boolean test(Apple apple) {
      return apple.getColor() == Color.GREEN;
    }

  }

  static class AppleRedAndHeavyPredicate implements ApplePredicate {

    @Override
    public boolean test(Apple apple) {
      return apple.getColor() == Color.RED && apple.getWeight() > 150;
    }

  }
```

Predicate를 이용해서 필터링 메소드를 바꾸면 다음과 같음
```
public static List<Apple> filter(List<Apple> inventory, ApplePredicate p) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
      if (p.test(apple)) {
        result.add(apple);
      }
    }
    return result;
  }
  
// [Apple{color=GREEN, weight=80}, Apple{color=GREEN, weight=155}]
List<Apple> greenApples2 = filter(inventory, new AppleColorPredicate());

// [Apple{color=GREEN, weight=155}]
List<Apple> heavyApples = filter(inventory, new AppleWeightPredicate());
    
// []
List<Apple> redAndHeavyApples = filter(inventory, new AppleRedAndHeavyPredicate());
```

이제 더이상 비슷한 코드를 복붙하고 수정하는 멍청한짓을 하지 않아도 됨  
ApplePredicate 인터페이스를 구현하는 클래스만 만들면 됨  

근데 이 코드도 좀 귀찮긴 함  
조건마다 구현하는 클래스를 저렇게 정성스럽게 정의해야되는데 이걸 개발자들이 참을리가 없음  
그래서 익명클래스, 람다를 사용하게 됨!
여기서부턴 다음시간에 계속..
