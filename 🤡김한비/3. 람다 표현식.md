## 1. 람다
> 메서드로 전달할 수 있는 익명 함수를 단순화 한 것

<br>

### 특징
* 익명함수
* 메서드 인수나 변수로 전달 가능
* 코드 작성을 간결하게 해줌

<br>

### 예시
사과 무게 비교하는 코드

    Comparator<Apple> byWeight = new Comparator<Apple>(){
        public int compare(Apple a1, Apple a2){
            return a1.getWeight().compareTo(a2.getWeight());
        }
    }

람다 사용  

    Comparator<Apple> byWeight = (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());

<br>

### 람다 구조
![image](https://user-images.githubusercontent.com/36736904/157433129-13752992-8e03-4906-804e-849abb8d9ef5.png)

<br>

### 유효한 람다 표현식

    (parameters) -> expression
    (parameters) -> {statements;}

<br>

### 퀴즈  
1. () -> {}  
2. () -> "Hanbi"  
3. () -> {return "ABC";}
4. (Integer i) -> return "Alan" + i;
5. (String s) -> {"Iron Man";}  

<br>

## 2. 람다를 활용하는 곳
### 1) 함수형 인터페이스와 함수 디스크립터
>함수형 인터페이스: 하나의 추상 메서드만 있는 인터페이스

람다표현식으로 함수형 인터페이스의 추성 메서드 구현을 직접 할 수 있다  
전체 표현식을 함수형 인터페이스의 인스턴스로 취급 가능  
익명 내부 클래스보다 깔끔하게 구현 가능  

<br>

#### 예시
    Runnable r1 = () -> System.out.println("hello world");

    Runnable r2 = new Runnable() {
        @Override
        public void run() {
            System.out.println("hello world");
        }
    };

    public static void process(Runnable r) {
        r.run();
    }

    process(r1);
    process(r2);
    process(()->System.out.println("hello world"));

<br>

#### 함수 디스크립터
>함수형 인터페이스의 추상 메서드 시그니처 => 람다 표현식의 시그니처  
함수 디스크립터: 람다 표현식의 시그니처를 서술하는 메서드

앞의 Runnable은 인자와 반환값이 없으므로, Runnable 인터페이스는 인자와 반환값이 없는 시그니처로 생각하면 됨  
예제 마지막줄이 함수 디스크립터라고 할 수 있음  
함수형 인터페이스를 인자로 받는 메서드에만 람다 표현식 사용 가능  
(설계자들이 생각했을때 이게 베스트였다고 함)  

<br>

#### 실행 어라운드 패턴에서 람다 활용하기(파일 읽기 예제)
> 실행 어라운드 패턴: 초기화/준비 코드 -> 작업 -> 정리/마무리 코드 형태  
> 작업은 달라지는데 나머지 코드가 중복되는 형태

예) 데이터베이스 자원처리  
자원열고 -> 디비에 작업하고 -> 자원 닫기

<br>

    public String processFile() throws IOException{
        try(BufferedReader br = new BufferedReader(new FileReader("data.txt"))){
            return br.readLine();
        }
    }

한번에 여러줄을 읽게 하려면 작업하는 코드를 반복해야함.  
코드 중복을 막기 위해 파일을 읽기 위해 설정하고 정리하는 코드는 재사용해야함  
=> processFile의 동작을 파라미터화  

<br>

processFile이 한번에 두 행을 읽는 코드

    String result = processFile((BufferedReader br)-> br.readLine()+br.readLine());

<br>

함수형 인터페이스에 람다를 사용할 수 있으니, 함수형 인터페이스를 만들어버림

    @FunctionalInterface
    public interface BufferedReaderProcessor{
        String process(BufferedReader b) throws IOException;

    ...
    
    public String processFile(BufferedReaderProcessor p) throws IOException{
        ...
    }

<br>

동작 실행

    public String processFile(BufferedReaderProcessor p) throws IOException{
        try(BufferedReader br = new BufferedReader(new FileReader("data.txt"))){
            return p.process(br);
        }

<br>

람다 전달
    
    String readOneLine = processFile(BufferedReader br) -> br.readLine());
    String readTwoLine = processFile(BufferedReader br) ->br.readLine())+br.readLine());

<br>

## 2. 함수형 인터페이스
